<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BarMatch - Encontre seu par no bar</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts & Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <style>
        /* Estilos customizados para complementar o Tailwind */
        body {
            font-family: 'Roboto', sans-serif;
        }
        .brand-logo {
            font-family: 'Lobster', cursive;
        }
        /* Efeito de gradiente no fundo */
        .gradient-bg {
            background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);
            background-size: 400% 400%;
            animation: gradient 15s ease infinite;
        }
        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Animações dos cards */
        .card {
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .card.dragging {
            transition: none;
            cursor: grabbing;
        }
        .card.like {
            transform: translateX(300px) rotate(20deg) !important; /* Aumentado o deslocamento para fora da tela */
            opacity: 0;
        }
        .card.dislike {
            transform: translateX(-300px) rotate(-20deg) !important; /* Aumentado o deslocamento para fora da tela */
            opacity: 0;
        }
        
        /* Estilo para a bolinha de online */
        .online-dot {
            width: 12px;
            height: 12px;
            background-color: #34D399; /* green-400 */
            border-radius: 50%;
            border: 2px solid white;
        }

        /* Estilo para a barra de scroll do chat */
        .chat-messages::-webkit-scrollbar {
            width: 8px;
        }
        .chat-messages::-webkit-scrollbar-track {
            background: #2d3748; /* gray-800 */
        }
        .chat-messages::-webkit-scrollbar-thumb {
            background: #4a5568; /* gray-700 */
            border-radius: 4px;
        }
        /* Alterado para que as mensagens mais recentes fiquem na parte inferior */
        .chat-messages {
            display: flex; /* Garante que é um flex container */
            flex-direction: column; /* Organiza os itens de cima para baixo */
        }

        /* Spinner de carregamento */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #e73c7e; /* Pink */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white overflow-hidden h-screen">

    <!-- Container Principal -->
    <div id="app-container" class="h-full w-full">

        <!-- Tela de Carregamento Inicial -->
        <div id="loading-screen" class="flex flex-col justify-center items-center h-full gradient-bg">
            <h1 class="brand-logo text-6xl text-white">BarMatch</h1>
            <p class="mt-2 text-white/80">Carregando...</p>
        </div>

        <!-- Tela de Erro (Sem ID do Bar) - Mantida para o caso de precisar no futuro -->
        <div id="error-screen" class="hidden flex-col justify-center items-center h-full bg-gray-900 text-center p-4">
             <span class="material-icons text-red-500 text-6xl mb-4">qr_code_scanner</span>
            <h2 class="text-2xl font-bold text-white">Oops! URL Inválida.</h2>
            <p class="mt-2 text-gray-400">Por favor, acesse este site escaneando o QR Code em um de nossos bares parceiros.</p>
        </div>

        <!-- Tela de Autenticação (Login/Cadastro) -->
        <div id="auth-screen" class="hidden h-full">
            <div class="h-full w-full flex flex-col justify-center items-center p-4 gradient-bg">
                <h1 class="brand-logo text-7xl text-white mb-8">BarMatch</h1>
                
                <!-- Formulário de Login -->
                <form id="login-form" class="w-full max-w-sm bg-gray-800/50 backdrop-blur-sm p-6 rounded-2xl shadow-lg">
                    <h2 class="text-2xl font-bold text-center text-white mb-6">Entrar</h2>
                    <input id="login-email" type="email" placeholder="Email" class="w-full bg-gray-700 text-white p-3 rounded-lg mb-4 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-pink-500" required>
                    <input id="login-password" type="password" placeholder="Senha" class="w-full bg-gray-700 text-white p-3 rounded-lg mb-4 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-pink-500" required>
                    <button type="submit" class="w-full bg-pink-600 hover:bg-pink-700 text-white font-bold p-3 rounded-lg transition-colors flex items-center justify-center">
                        Entrar
                        <span id="login-spinner" class="loader ml-2 hidden"></span>
                    </button>
                    <p class="text-center text-gray-400 text-sm mt-4">Não tem uma conta? <a href="#" id="show-register" class="text-pink-400 hover:underline">Cadastre-se</a></p>
                </form>

                <!-- Formulário de Cadastro -->
                <form id="register-form" class="hidden w-full max-w-sm bg-gray-800/50 backdrop-blur-sm p-6 rounded-2xl shadow-lg">
                    <h2 class="text-2xl font-bold text-center text-white mb-6">Criar Conta</h2>
                    <input id="register-name" type="text" placeholder="Primeiro Nome" class="w-full bg-gray-700 text-white p-3 rounded-lg mb-4 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-pink-500" required>
                    <input id="register-email" type="email" placeholder="Email" class="w-full bg-gray-700 text-white p-3 rounded-lg mb-4 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-pink-500" required>
                    <input id="register-password" type="password" placeholder="Senha (mín. 6 caracteres)" class="w-full bg-gray-700 text-white p-3 rounded-lg mb-4 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-pink-500" required>
                    <textarea id="register-bio" placeholder="Sua bio (opcional)" rows="2" class="w-full bg-gray-700 text-white p-3 rounded-lg mb-4 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-pink-500"></textarea>
                    
                    <!-- Campos de cadastro atualizados -->
                    <select id="register-gender" class="w-full bg-gray-700 text-white p-3 rounded-lg mb-4 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-pink-500" required>
                        <option value="">Selecione seu Gênero</option>
                        <option value="masculino">Masculino</option>
                        <option value="feminino">Feminino</option>
                        <option value="nao-binario">Não Binário</option>
                        <option value="prefiro-nao-dizer">Prefiro não dizer</option>
                    </select>
                    <select id="register-preferred-gender" class="w-full bg-gray-700 text-white p-3 rounded-lg mb-4 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-pink-500" required>
                        <option value="">Interessado(a) em</option>
                        <option value="homens">Homens</option>
                        <option value="mulheres">Mulheres</option>
                        <option value="nao-binario">Não Binário</option>
                        <option value="todos">Todos</option>
                    </select>
                    <!-- Campo de upload de foto -->
                    <div>
                        <label for="register-photo" class="block text-sm font-medium text-gray-400 mb-1">Foto de Perfil</label>
                        <input id="register-photo" type="file" accept="image/*" class="w-full bg-gray-700 text-white p-3 rounded-lg mb-4 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-pink-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-pink-50 file:text-pink-700 hover:file:bg-pink-100" required>
                    </div>
                    <button type="submit" class="w-full bg-pink-600 hover:bg-pink-700 text-white font-bold p-3 rounded-lg transition-colors flex items-center justify-center">
                        Cadastrar
                        <span id="register-spinner" class="loader ml-2 hidden"></span>
                    </button>
                    <p class="text-center text-gray-400 text-sm mt-4">Não tem uma conta? <a href="#" id="show-login" class="text-pink-400 hover:underline">Entrar</a></p>
                </form>

                <p id="auth-error" class="text-red-400 mt-4 text-center"></p>
            </div>
        </div>

        <!-- Tela Principal do App -->
        <main id="app-screen" class="hidden h-full w-full flex-col">
            <!-- Header do App -->
            <header class="flex justify-between items-center p-4 bg-gray-900/80 backdrop-blur-sm z-10">
                <button id="profile-btn" class="p-2 rounded-full hover:bg-gray-700">
                    <span class="material-icons">person</span>
                </button>
                <h1 class="brand-logo text-4xl text-pink-500">BarMatch</h1>
                <div class="flex items-center space-x-2">
                    <button id="matches-btn" class="p-2 rounded-full hover:bg-gray-700 relative">
                        <span class="material-icons">forum</span>
                        <!-- Notification dot for new matches/messages -->
                        <span id="match-notification" class="hidden absolute -top-1 -right-1 w-3 h-3 bg-red-600 rounded-full border-2 border-gray-900"></span>
                    </button>
                    <button id="logout-main-btn" class="p-2 rounded-full hover:bg-gray-700">
                        <span class="material-icons">logout</span>
                    </button>
                </div>
            </header>

            <!-- Display do User ID -->
            <div class="text-center text-gray-400 text-sm py-1 bg-gray-900/50">
                <p>Seu UID: <span id="display-user-id">Carregando...</span></p>
            </div>

            <!-- Área dos Cards -->
            <div id="card-area" class="flex-grow relative flex justify-center items-center overflow-hidden p-4">
                <!-- Mensagem de "Sem mais usuários" -->
                <div id="no-more-users" class="hidden text-center">
                    <span class="material-icons text-6xl text-gray-500">sentiment_dissatisfied</span>
                    <h3 class="text-xl font-bold mt-4">Ninguém novo por perto</h3>
                    <p class="text-gray-400">Parece que você já viu todos por aqui. Volte mais tarde!</p>
                </div>
            </div>

            <!-- Os botões globais de ação foram removidos daqui para evitar duplicação -->
            <!-- Eles agora são gerados dinamicamente dentro de cada card -->
            <footer class="hidden"></footer> 
        </main>

        <!-- Modal de Match -->
        <div id="match-modal" class="hidden fixed inset-0 bg-black/80 flex flex-col justify-center items-center z-50">
            <div class="text-center">
                <h2 class="text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-500 to-yellow-500 mb-4">É um Match!</h2>
                <p class="text-xl text-white mb-6">Você e <span id="match-name"></span> se curtiram!</p>
                <div class="flex justify-center items-center space-x-[-20px] mb-8">
                    <img id="match-photo-user" src="https://placehold.co/120x120/7e22ce/ffffff?text=Eu" class="w-32 h-32 rounded-full border-4 border-pink-500 object-cover">
                    <img id="match-photo-other" src="https://placehold.co/120x120/4a5568/ffffff?text=?" class="w-32 h-32 rounded-full border-4 border-white object-cover">
                </div>
                <button id="chat-now-btn" class="w-full max-w-xs bg-pink-600 hover:bg-pink-700 text-white font-bold py-3 px-4 rounded-full transition-colors mb-4">Enviar uma mensagem</button>
                <button id="keep-swiping-btn" class="w-full max-w-xs bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 px-4 rounded-full transition-colors">Continuar procurando</button>
            </div>
        </div>
        
        <!-- Tela de Perfil e Configurações -->
        <div id="profile-screen" class="hidden fixed inset-0 bg-gray-900 z-40 flex flex-col p-4">
             <div class="flex justify-between items-center mb-6">
                <button id="back-to-app-from-profile" class="p-2 rounded-full hover:bg-gray-700">
                    <span class="material-icons">arrow_back</span>
                </button>
                <h2 class="text-2xl font-bold">Meu Perfil</h2>
                <button id="logout-btn" class="p-2 rounded-full hover:bg-gray-700">
                    <span class="material-icons">logout</span>
                </button>
            </div>
            <div class="flex-grow overflow-y-auto">
                 <form id="profile-form" class="space-y-4">
                     <div class="flex justify-center">
                        <img id="profile-img-preview" src="https://placehold.co/150x150/7e22ce/ffffff?text=Perfil" class="w-40 h-40 rounded-full border-4 border-pink-500 object-cover">
                     </div>
                     <div>
                        <label for="profile-photo" class="block text-sm font-medium text-gray-400">Foto de Perfil</label>
                        <input type="file" id="profile-photo" accept="image/*" class="mt-1 w-full bg-gray-800 text-white p-3 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-2 focus:ring-pink-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-pink-50 file:text-pink-700 hover:file:bg-pink-100">
                    </div>
                    <div>
                        <label for="profile-name" class="block text-sm font-medium text-gray-400">Nome</label>
                        <input type="text" id="profile-name" class="mt-1 w-full bg-gray-800 text-white p-3 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-pink-500">
                    </div>
                     <div>
                        <label for="profile-bio" class="block text-sm font-medium text-gray-400">Bio</label>
                        <textarea id="profile-bio" rows="4" class="mt-1 w-full bg-gray-800 text-white p-3 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-pink-500"></textarea>
                    </div>
                    <!-- Novos campos de perfil -->
                    <div>
                        <label for="profile-gender" class="block text-sm font-medium text-gray-400">Seu Gênero</label>
                        <select id="profile-gender" class="mt-1 w-full bg-gray-800 text-white p-3 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-pink-500">
                            <option value="">Selecione seu Gênero</option>
                            <option value="masculino">Masculino</option>
                            <option value="feminino">Feminino</option>
                            <option value="nao-binario">Não Binário</option>
                            <option value="prefiro-nao-dizer">Prefiro não dizer</option>
                        </select>
                    </div>
                    <div>
                        <label for="profile-preferred-gender" class="block text-sm font-medium text-gray-400">Interessado(a) em</label>
                        <select id="profile-preferred-gender" class="mt-1 w-full bg-gray-800 text-white p-3 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-pink-500">
                            <option value="">Interessado(a) em</option>
                            <option value="homens">Homens</option>
                            <option value="mulheres">Mulheres</option>
                            <option value="nao-binario">Não Binário</option>
                            <option value="todos">Todos</option>
                        </select>
                    </div>
                    <button type="submit" class="w-full bg-pink-600 hover:bg-pink-700 text-white font-bold p-3 rounded-lg transition-colors flex items-center justify-center">
                        Salvar Alterações
                        <span id="profile-spinner" class="loader ml-2 hidden"></span>
                    </button>
                </form>
            </div>
        </div>

        <!-- Nova Modal de Visualização de Perfil de Outro Usuário -->
        <div id="user-profile-modal" class="hidden fixed inset-0 bg-black/80 flex flex-col z-[60] p-4 overflow-y-auto">
            <div class="flex justify-between items-center mb-6">
                <button id="close-user-profile-modal" class="p-2 rounded-full hover:bg-gray-700">
                    <span class="material-icons">arrow_back</span>
                </button>
                <h2 class="text-2xl font-bold" id="user-profile-modal-name">Perfil do Usuário</h2>
                <div class="w-10"></div> <!-- Placeholder para centralizar o título -->
            </div>
            <div class="flex flex-col items-center">
                <img id="user-profile-modal-img" src="https://placehold.co/150x150/4a5568/ffffff?text=Perfil" class="w-40 h-40 rounded-full border-4 border-pink-500 object-cover mb-4">
                <p class="text-white text-lg font-bold mb-2" id="user-profile-modal-name-main"></p>
                <p class="text-gray-300 text-center mb-4" id="user-profile-modal-bio"></p>
                <div class="bg-gray-800 p-4 rounded-lg w-full max-w-md">
                    <p class="text-gray-400"><span class="font-semibold text-white">Gênero:</span> <span id="user-profile-modal-gender"></span></p>
                    <p class="text-gray-400"><span class="font-semibold text-white">Interessado(a) em:</span> <span id="user-profile-modal-preferred-gender"></span></p>
                </div>
            </div>
        </div>
        
        <!-- Tela de Matches e Chats -->
        <div id="matches-screen" class="hidden fixed inset-0 bg-gray-900 z-40 flex flex-col">
            <header class="flex items-center p-4 border-b border-gray-700">
                 <button id="back-to-app-from-matches" class="p-2 rounded-full hover:bg-gray-700 mr-4">
                    <span class="material-icons">arrow_back</span>
                </button>
                <h2 class="text-2xl font-bold">Matches</h2>
            </header>
            <div id="matches-list" class="flex-grow overflow-y-auto p-2">
                <!-- Lista de matches será populada aqui -->
                 <p id="no-matches-found" class="text-center text-gray-500 mt-4 hidden">Nenhum match encontrado ainda. Continue deslizando!</p>
            </div>
        </div>

        <!-- Tela de Chat Individual -->
        <div id="chat-screen" class="hidden fixed inset-0 bg-gray-800 z-50 flex flex-col">
            <header class="flex items-center p-3 bg-gray-900 shadow-md">
                <button id="back-to-matches-from-chat" class="p-2 rounded-full hover:bg-gray-700 mr-3">
                    <span class="material-icons">arrow_back</span>
                </button>
                <img id="chat-header-img" src="https://placehold.co/40x40/4a5568/ffffff?text=?" class="w-10 h-10 rounded-full object-cover mr-3 cursor-pointer">
                <h2 id="chat-header-name" class="font-bold text-lg cursor-pointer">Nome do Match</h2>
            </header>
            <div id="chat-messages" class="chat-messages flex-grow p-4 overflow-y-auto">
                <!-- Mensagens do chat serão populadas aqui -->
                <p id="no-messages-yet" class="text-center text-gray-500 mt-4 hidden">Comece a conversa!</p>
            </div>
            <footer class="p-3 bg-gray-900">
                <form id="chat-form" class="flex items-center">
                    <input id="chat-input" type="text" placeholder="Digite uma mensagem..." class="flex-grow bg-gray-700 text-white p-3 rounded-full focus:outline-none px-5" autocomplete="off">
                    <button type="submit" class="ml-3 bg-pink-600 text-white p-3 rounded-full">
                        <span class="material-icons">send</span>
                    </button>
                </form>
            </footer>
        </div>

        <!-- Custom Confirmation Modal -->
        <div id="confirmation-modal" class="hidden fixed inset-0 bg-black/80 flex justify-center items-center z-[9999]">
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg text-center max-w-sm w-full mx-4">
                <p id="confirmation-message" class="text-lg text-white mb-6">Você tem certeza?</p>
                <div class="flex justify-center space-x-4">
                    <button id="confirm-yes" class="px-6 py-2 bg-pink-600 hover:bg-pink-700 text-white rounded-md font-bold transition-colors">Sim</button>
                    <button id="confirm-no" class="px-6 py-2 bg-gray-600 hover:bg-gray-500 text-white rounded-md font-bold transition-colors">Não</button>
                </div>
            </div>
        </div>

        <!-- Custom Message Modal -->
        <div id="message-modal" class="hidden fixed inset-0 bg-black/80 flex justify-center items-center z-[9998]">
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg text-center max-w-sm w-full mx-4">
                <p id="message-content" class="text-lg text-white mb-6">Mensagem aqui.</p>
                <button id="message-ok" class="px-6 py-2 bg-pink-600 hover:bg-pink-700 text-white rounded-md font-bold transition-colors">OK</button>
            </div>
        </div>

    </div>

    <!-- Firebase -->
    <script type="module">
        // Importações do Firebase SDK
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            onAuthStateChanged, 
            signOut
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            getDoc,
            collection,
            query,
            where,
            getDocs,
            onSnapshot,
            serverTimestamp,
            addDoc,
            Timestamp // Importação do Timestamp para consultas
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CONFIGURAÇÃO INICIAL ---
        
        // As configurações do Firebase serão injetadas aqui
        const firebaseConfig = {
            apiKey: "AIzaSyAOdQ3a3pZ5Ic-83yw7XQm_5O4fQwHt_Yg",
            authDomain: "barmatchprojeto.firebaseapp.com",
            projectId: "barmatchprojeto",
            storageBucket: "barmatchprojeto.firebasestorage.app", 
            messagingSenderId: "552395668923",
            appId: "1:552395668923:web:a5422c31ad9f1269bf189e",
            measurementId: "G-W9V7ZV1ENQ"
        };
        // Use __app_id provided by the environment, or a default for local testing
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-bar-match';

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- CONSTANTES PARA REDIMENSIONAMENTO DE IMAGEM ---
        const MAX_IMAGE_WIDTH = 300; // Largura máxima em pixels
        const MAX_IMAGE_HEIGHT = 300; // Altura máxima em pixels
        const JPEG_QUALITY = 0.8; // Qualidade JPEG (0.0 a 1.0) para arquivos menores

        // --- VARIÁVEIS DE ESTADO E ELEMENTOS DO DOM ---
        let currentUser = null;
        let barId = null;
        let currentCard = null;
        let potentialMatches = [];
        let unsubscribeCheckIns = null;
        let unsubscribeMatches = null; // Renomeado para maior clareza
        let unsubscribeChat = null;
        let unsubscribeMatchDoc = null; // NOVA: Listener para o documento do match
        let currentChatMatch = null;
        let activeChatMatchId = null; // NOVA: Variável para controlar o ID do chat ativo
        let currentMessagesCache = []; // Cache para as mensagens do chat
        let otherUserLastReadTimestamp = 0; // Timestamp de última leitura do outro usuário

        // Telas
        const loadingScreen = document.getElementById('loading-screen');
        const errorScreen = document.getElementById('error-screen');
        const authScreen = document.getElementById('auth-screen');
        const appScreen = document.getElementById('app-screen');
        const profileScreen = document.getElementById('profile-screen');
        const userProfileModal = document.getElementById('user-profile-modal'); // Nova modal
        const matchesScreen = document.getElementById('matches-screen');
        const chatScreen = document.getElementById('chat-screen');
        const matchModal = document.getElementById('match-modal');

        // Formulários
        const loginForm = document.getElementById('login-form');
        const registerForm = document.getElementById('register-form');
        const profileForm = document.getElementById('profile-form');
        const chatForm = document.getElementById('chat-form');

        // Botões - REFERÊNCIAS REMOVIDAS POIS AGORA SÃO GLOBAIS NO CÓDIGO
        // const likeBtn = document.getElementById('like-btn'); 
        // const dislikeBtn = document.getElementById('dislike-btn');
        const logoutBtn = document.getElementById('logout-btn'); 
        const logoutMainBtn = document.getElementById('logout-main-btn');
        const profileBtn = document.getElementById('profile-btn');
        const backToAppFromProfile = document.getElementById('back-to-app-from-profile');
        const closeUserProfileModalBtn = document.getElementById('close-user-profile-modal'); // Botão para fechar a nova modal
        const matchesBtn = document.getElementById('matches-btn');
        const backToAppFromMatches = document.getElementById('back-to-app-from-matches'); 
        const chatNowBtn = document.getElementById('chat-now-btn');
        const keepSwipingBtn = document.getElementById('keep-swiping-btn');
        const backToMatchesFromChat = document.getElementById('back-to-matches-from-chat');
        const showRegisterBtn = document.getElementById('show-register');
        const showLoginBtn = document.getElementById('show-login');
        
        // Outros
        const cardArea = document.getElementById('card-area');
        const noMoreUsersMsg = document.getElementById('no-more-users');
        const authError = document.getElementById('auth-error'); // Element for auth specific errors (não mais usado diretamente)
        const loginSpinner = document.getElementById('login-spinner');
        const registerSpinner = document.getElementById('register-spinner');
        const profileSpinner = document.getElementById('profile-spinner');
        const displayUserId = document.getElementById('display-user-id');
        const noMatchesFoundMsg = document.getElementById('no-matches-found'); // Mensagem para nenhum match
        const noMessagesYetMsg = document.getElementById('no-messages-yet'); // Mensagem para nenhum chat

        // Notificações
        const matchNotification = document.getElementById('match-notification'); // Agora é apenas o dot

        // Custom Modals elements
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmationMessage = document.getElementById('confirmation-message');
        const confirmYesBtn = document.getElementById('confirm-yes');
        const confirmNoBtn = document.getElementById('confirm-no');
        const messageModal = document.getElementById('message-modal');
        const messageContent = document.getElementById('message-content');
        const messageOkBtn = document.getElementById('message-ok');

        // File input and preview elements
        const registerPhotoInput = document.getElementById('register-photo');
        const profilePhotoInput = document.getElementById('profile-photo');
        const profileImgPreview = document.getElementById('profile-img-preview');

        // --- Custom Modal Functions ---
        /**
         * Mostra um modal de confirmação personalizado.
         * @param {string} message - A mensagem a ser exibida.
         * @returns {Promise<boolean>} - Resolve para true se confirmado, false caso contrário.
         */
        function showConfirmation(message) {
            return new Promise((resolve) => {
                confirmationMessage.textContent = message;
                confirmationModal.classList.remove('hidden');

                const onYes = () => {
                    confirmationModal.classList.add('hidden');
                    confirmYesBtn.removeEventListener('click', onYes);
                    confirmNoBtn.removeEventListener('click', onNo);
                    resolve(true);
                };

                const onNo = () => {
                    confirmationModal.classList.add('hidden');
                    confirmYesBtn.removeEventListener('click', onYes);
                    confirmNoBtn.removeEventListener('click', onNo);
                    resolve(false);
                };

                confirmYesBtn.addEventListener('click', onYes);
                confirmNoBtn.addEventListener('click', onNo);
            });
        }

        /**
         * Mostra um modal de mensagem personalizado.
         * @param {string} message - A mensagem a ser exibida.
         * @returns {Promise<void>} - Resolve quando o botão OK é clicado.
         */
        function showMessage(message) {
            return new Promise((resolve) => {
                messageContent.textContent = message;
                messageModal.classList.remove('hidden');

                const onOk = () => {
                    messageModal.classList.add('hidden');
                    messageOkBtn.removeEventListener('click', onOk);
                    resolve();
                };

                messageOkBtn.addEventListener('click', onOk);
            });
        }


        /**
         * Redimensiona um arquivo de imagem e o converte para uma string Base64.
         * @param {File} file - O arquivo de imagem a ser processado.
         * @param {number} maxWidth - Largura máxima para a imagem redimensionada.
         * @param {number} maxHeight - Altura máxima para a imagem redimensionada.
         * @returns {Promise<string>} - Uma Promise que resolve com a string Base64 da imagem redimensionada.
         */
        async function resizeImageAndConvertToBase64(file, maxWidth, maxHeight) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let width = img.width;
                        let height = img.height;

                        // Calcula novas dimensões, mantendo a proporção
                        if (width > height) {
                            if (width > maxWidth) {
                                height *= maxWidth / width;
                                width = maxWidth;
                            }
                        } else {
                            if (height > maxHeight) {
                                width *= maxHeight / height;
                                height = maxHeight;
                            }
                        }

                        canvas.width = width;
                        canvas.height = height;

                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);

                        // Converte o canvas para string Base64
                        // Usando 'image/jpeg' com 80% de qualidade para um tamanho de arquivo menor
                        resolve(canvas.toDataURL('image/jpeg', JPEG_QUALITY)); 
                    };
                    img.onerror = (error) => reject(new Error("Erro ao carregar imagem para redimensionamento: " + error.target.error));
                    img.src = e.target.result;
                };
                reader.onerror = (error) => reject(new Error("Erro ao ler arquivo: " + error));
                reader.readAsDataURL(file);
            });
        }

        // --- LÓGICA PRINCIPAL ---

        // 1. Inicialização da Aplicação
        window.onload = function() {
            const urlParams = new URLSearchParams(window.location.search);
            barId = urlParams.get('barId');

            // *** MUDANÇA PARA TESTE LOCAL ***
            // Se nenhum barId for encontrado na URL, define um padrão para evitar a tela de erro.
            if (!barId) {
                console.warn("Nenhum 'barId' encontrado na URL. Usando 'bar-de-teste-local' para desenvolvimento.");
                barId = 'bar-de-teste-local';
            }
            
            // Não há mais tentativa de login automático aqui.
            // O onAuthStateChanged será o primeiro a ser acionado e levará para a tela de autenticação.

            // 2. onAuthStateChanged listener (reacts to ANY auth state change)
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentUser = user;
                    console.log("onAuthStateChanged: User ID:", user.uid);
                    console.log("onAuthStateChanged: Is Anonymous:", user.isAnonymous);
                    displayUserId.textContent = currentUser.uid; // Atualiza o display do UID

                    try {
                        await checkInUser(user.uid);
                        await loadUserProfile();
                        showScreen('app'); 
                        loadPotentialMatches(); 
                        listenForMatches(); 
                    }
                    catch (error) {
                        console.error("Erro ao inicializar o app para o utilizador:", error);
                        if (error.code === 'permission-denied') {
                            showMessage("Erro de permissão! Por favor, verifique as regras de segurança do seu Firebase Firestore. Detalhes: " + error.message);
                        } else {
                            showMessage("Ocorreu um erro ao carregar os seus dados. Tente novamente. Detalhes: " + error.message);
                        }
                        showScreen('error'); // Mostra ecrã de erro genérico
                    }
                } else {
                    console.log("onAuthStateChanged: Utilizador desconectado ou nenhum utilizador.");
                    currentUser = null;
                    displayUserId.textContent = 'N/A'; // Limpa o display do UID
                    showScreen('auth'); 
                    if(unsubscribeCheckIns) clearInterval(unsubscribeCheckIns);
                    if(unsubscribeMatches) unsubscribeMatches(); // Limpa listener de matches
                    if(unsubscribeChat) unsubscribeChat(); 
                    if(unsubscribeMatchDoc) unsubscribeMatchDoc(); // NOVA: Limpa o listener do documento do match
                    activeChatMatchId = null; // Limpa o chat ativo ao deslogar

                    potentialMatches = [];
                    if (currentCard) {
                        if(cardArea.contains(currentCard)) {
                            cardArea.removeChild(currentCard);
                        }
                        currentCard = null;
                    }
                    noMoreUsersMsg.classList.add('hidden'); 
                }
            });
        };

        // 2. Gerenciamento de Telas
        function showScreen(screenName) {
            loadingScreen.style.display = 'none';
            errorScreen.style.display = 'none';
            authScreen.style.display = 'none';
            appScreen.style.display = 'none';
            profileScreen.classList.add('hidden'); 
            userProfileModal.classList.add('hidden'); // Esconde a nova modal de perfil de usuário
            matchesScreen.classList.add('hidden'); 
            chatScreen.classList.add('hidden'); 

            if (screenName === 'error') errorScreen.style.display = 'flex';
            if (screenName === 'auth') authScreen.style.display = 'block';
            if (screenName === 'app') appScreen.style.display = 'flex';
        }

        // 3. Autenticação e Perfil
        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            loginSpinner.classList.remove('hidden'); // Mostra spinner
            try {
                const email = document.getElementById('login-email').value;
                const password = document.getElementById('login-password').value;
                await signInWithEmailAndPassword(auth, email, password);
            } catch (error) {
                console.error("Erro no login:", error);
                let errorMessage = "Erro no login. Verifique o seu email e palavra-passe.";
                if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential') {
                    errorMessage = "Email ou palavra-passe inválidos.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Formato de email inválido.";
                } else if (error.code === 'auth/too-many-requests') {
                    errorMessage = "Demasiadas tentativas de login. Tente novamente mais tarde.";
                }
                showMessage(errorMessage); // Exibe mensagem de erro no modal customizado
            } finally {
                loginSpinner.classList.add('hidden'); // Esconde spinner
            }
        });

        registerForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            registerSpinner.classList.remove('hidden'); // Mostra spinner
            const file = registerPhotoInput.files[0];

            if (!file) {
                showMessage("Por favor, selecione uma foto de perfil.");
                registerSpinner.classList.add('hidden');
                return;
            }

            try {
                const email = document.getElementById('register-email').value;
                const password = document.getElementById('register-password').value;
                const name = document.getElementById('register-name').value;
                const bio = document.getElementById('register-bio').value;
                const gender = document.getElementById('register-gender').value;
                const preferredGender = document.getElementById('register-preferred-gender').value;
                
                // Converte e redimensiona a imagem para Base64
                const photoURL = await resizeImageAndConvertToBase64(file, MAX_IMAGE_WIDTH, MAX_IMAGE_HEIGHT);

                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                const user = userCredential.user;

                // Salva informações no Firestore, incluindo a imagem Base64
                const userDocRef = doc(db, `artifacts/${appId}/public/data/user_profiles`, user.uid);
                await setDoc(userDocRef, {
                    name: name,
                    email: email,
                    bio: bio,
                    photoURL: photoURL, // Armazenando a string Base64
                    gender: gender, 
                    preferredGender: preferredGender, 
                    createdAt: serverTimestamp()
                });
                showMessage("Registo realizado com sucesso! Já pode usar o BarMatch."); // Mensagem de sucesso
                // onAuthStateChanged irá lidar com a mudança de tela devido à nova credencial do utilizador
            } catch (error) {
                console.error("Erro no registo:", error);
                let errorMessage = "Não foi possível criar a conta. Verifique os dados e tente novamente.";
                if (error.code === 'auth/email-already-in-use') {
                    errorMessage = "Este email já está em uso.";
                } else if (error.code === 'auth/weak-password') {
                    errorMessage = "A palavra-passe é muito fraca (mínimo 6 caracteres).";
                } else if (error.code === 'permission-denied') {
                    errorMessage = "Erro de permissão ao guardar perfil. Verifique as regras de segurança do Firebase Firestore.";
                } else if (error.message && error.message.includes("is longer than")) {
                    errorMessage = "A imagem selecionada é muito grande. Por favor, selecione uma imagem menor.";
                }
                else {
                    errorMessage = "Erro ao criar conta. Detalhes: " + error.message;
                }
                showMessage(errorMessage); // Exibe mensagem de erro no modal customizado
            } finally {
                registerSpinner.classList.add('hidden'); // Esconde spinner
            }
        });
        
        // Event listener para o botão de logout no ecrã de perfil
        logoutBtn.addEventListener('click', async () => {
             const confirmed = await showConfirmation("Tem a certeza que quer sair?");
             if(confirmed){
                signOut(auth);
             }
        });

        // Event listener para o novo botão de logout no cabeçalho da aplicação principal
        logoutMainBtn.addEventListener('click', async () => {
            const confirmed = await showConfirmation("Tem a certeza que quer sair?");
            if(confirmed){
                signOut(auth);
            }
        });
        
        showRegisterBtn.addEventListener('click', (e) => {
            e.preventDefault();
            loginForm.classList.add('hidden');
            registerForm.classList.remove('hidden');
        });

        showLoginBtn.addEventListener('click', (e) => {
            e.preventDefault();
            registerForm.classList.add('hidden');
            loginForm.classList.remove('hidden');
        });

        // Event listener para pré-visualização da foto no registo
        registerPhotoInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                try {
                    // Apenas para pré-visualização, não faz upload real aqui
                    // Redimensiona para uma pré-visualização mais leve
                    const base64String = await resizeImageAndConvertToBase64(file, 150, 150); 
                    // Se houvesse um <img> no formulário de registo, poderíamos usá-lo:
                    // document.getElementById('register-img-preview').src = base64String;
                } catch (error) {
                    console.error("Erro na pré-visualização da imagem (Base64):", error);
                    showMessage("Não foi possível carregar a pré-visualização da imagem. Tente outra imagem.");
                }
            }
        });


        // 4. Lógica de "Check-in" no Bar
        async function checkInUser(userId) {
            try {
                const checkInRef = doc(db, `artifacts/${appId}/public/data/check_ins`, userId);
                await setDoc(checkInRef, {
                    barId: barId,
                    lastSeen: serverTimestamp(),
                    userId: userId
                }, { merge: true }); 
                if (unsubscribeCheckIns) clearInterval(unsubscribeCheckIns); 

                unsubscribeCheckIns = setInterval(() => {
                    if(auth.currentUser) {
                        setDoc(checkInRef, { lastSeen: serverTimestamp() }, { merge: true }).catch(err => {
                            console.error("Erro ao atualizar lastSeen:", err);
                            if (err.code === 'permission-denied') {
                                showMessage("Erro de permissão ao atualizar presença. Verifique as regras do Firebase.");
                                clearInterval(unsubscribeCheckIns); // Para de tentar se as permissões falharem
                                unsubscribeCheckIns = null;
                            }
                        });
                    } else {
                        clearInterval(unsubscribeCheckIns); 
                        unsubscribeCheckIns = null;
                    }
                }, 60 * 1000);
            } catch (error) {
                console.error("Erro no check-in do utilizador:", error);
                if (error.code === 'permission-denied') {
                    showMessage("Erro de permissão ao fazer check-in. Verifique as regras de segurança do Firebase.");
                } else {
                    showMessage("Erro ao realizar check-in no bar. Detalhes: " + error.message);
                }
                // Não lança erro, permite que o resto da aplicação carregue se possível
            }
        }

        // 5. Lógica de "Matching" (Carregar e exibir cards)
        async function loadPotentialMatches() {
            noMoreUsersMsg.classList.add('hidden');
            cardArea.innerHTML = ''; 
            
            try {
                // Garante que currentUser está disponível antes de prosseguir com as queries do Firestore
                if (!currentUser || !currentUser.uid) {
                    console.warn("loadPotentialMatches: Nenhum utilizador atual ou UID disponível. Não é possível carregar matches.");
                    noMoreUsersMsg.classList.remove('hidden');
                    return;
                }

                const swipesRef = collection(db, `artifacts/${appId}/users/${currentUser.uid}/swipes`);
                const swipesSnapshot = await getDocs(swipesRef);
                const swipedUserIds = swipesSnapshot.docs.map(doc => doc.id);
                swipedUserIds.push(currentUser.uid); 

                const threeHoursAgo = new Date(Date.now() - 3 * 60 * 60 * 1000);
                const checkInsQuery = query(collection(db, `artifacts/${appId}/public/data/check_ins`), 
                    where("barId", "==", barId),
                    where("lastSeen", ">", threeHoursAgo)
                );

                const checkInsSnapshot = await getDocs(checkInsQuery);
                let userIdsInBar = checkInsSnapshot.docs
                    .map(doc => doc.data().userId)
                    .filter(id => !swipedUserIds.includes(id));
                
                if (userIdsInBar.length === 0) {
                    noMoreUsersMsg.classList.remove('hidden');
                    return;
                }

                const currentUserProfileDoc = await getDoc(doc(db, `artifacts/${appId}/public/data/user_profiles`, currentUser.uid));
                const currentUserProfileData = currentUserProfileDoc.exists() ? currentUserProfileDoc.data() : {};
                const userPreferredGender = currentUserProfileData.preferredGender;

                let usersToFetch = userIdsInBar; 

                // Se o utilizador tem uma preferência de género específica (não "todos")
                if (userPreferredGender && userPreferredGender !== 'todos') {
                    let targetGenderForQuery = '';
                    if (userPreferredGender === 'homens') {
                        targetGenderForQuery = 'masculino';
                    } else if (userPreferredGender === 'mulheres') {
                        targetGenderForQuery = 'feminino';
                    } else if (userPreferredGender === 'nao-binario') {
                        targetGenderForQuery = 'nao-binario';
                    }

                    if (targetGenderForQuery) {
                        const filteredUserProfiles = [];
                        // A query 'in' do Firestore tem um limite de 10. Processa em lotes se necessário.
                        // Para simplificar, assumimos que userIdsInBar não excederá isto.
                        // Se exceder, é necessário um mecanismo de loteamento ou uma abordagem de query diferente.
                        const allPotentialUsersSnapshot = await getDocs(query(collection(db, `artifacts/${appId}/public/data/user_profiles`), where("__name__", "in", userIdsInBar)));
                        allPotentialUsersSnapshot.forEach(doc => {
                            const userData = doc.data();
                            if (userData.gender === targetGenderForQuery) {
                                filteredUserProfiles.push({ id: doc.id, ...userData });
                            }
                        });
                        potentialMatches = filteredUserProfiles; 
                    } else {
                        potentialMatches = [];
                    }
                } else {
                    const allPotentialUsersSnapshot = await getDocs(query(collection(db, `artifacts/${appId}/public/data/user_profiles`), where("__name__", "in", usersToFetch)));
                    potentialMatches = allPotentialUsersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                }

                if (potentialMatches.length === 0) {
                    noMoreUsersMsg.classList.remove('hidden');
                    return;
                }
                
                renderNextCard();

            }  catch (error) {
                console.error("Erro ao carregar matches potenciais:", error);
                if (error.code === 'permission-denied') {
                    showMessage("Erro de permissão ao carregar perfis para matching. Verifique as regras de segurança do Firebase. Detalhes: " + error.message);
                } else {
                    showMessage("Erro ao carregar perfis. Por favor, tente novamente. Detalhes: " + error.message);
                }
                noMoreUsersMsg.classList.remove('hidden'); 
            }
        }


        function renderNextCard() {
            if (currentCard) {
                if(cardArea.contains(currentCard)) {
                    cardArea.removeChild(currentCard);
                }
                currentCard = null;
            }

            if (potentialMatches.length === 0) {
                noMoreUsersMsg.classList.remove('hidden');
                return;
            }

            const user = potentialMatches.pop();
            currentCard = createCardElement(user);
            currentCard.dataset.userId = user.id; 
            cardArea.appendChild(currentCard);
            setupCardInteractions(currentCard, user);
        }
        
        function createCardElement(user) {
            const card = document.createElement('div');
            // Alterações para padronizar o tamanho das fotos e ajustar o posicionamento dos botões.
            // Definindo uma altura e largura fixa para o container da imagem e usando object-cover
            card.className = 'card absolute w-full max-w-sm h-[500px] bg-gray-800 rounded-2xl shadow-xl overflow-hidden cursor-grab flex flex-col justify-between'; 
            card.innerHTML = `
                <div class="relative w-full h-[calc(100%-100px)]"> <!-- Altura calculada para deixar espaço para os botões e texto -->
                    <img src="${user.photoURL || 'https://placehold.co/600x800/4a5568/ffffff?text=Sem+Foto'}" class="w-full h-full object-cover" onerror="this.src='https://placehold.co/600x800/4a5568/ffffff?text=Erro'">
                    <div class="absolute inset-x-0 bottom-0 w-full h-1/3 bg-gradient-to-t from-black/80 to-transparent p-4 flex flex-col justify-end">
                        <h3 class="text-3xl font-bold text-white">${user.name}</h3>
                        <p class="text-white/90 truncate">${user.bio || ''}</p>
                        <p class="text-white/80 text-sm mt-1">Gênero: ${user.gender || 'Não informado'}</p>
                        <p class="text-white/80 text-sm">Interessado(a) em: ${user.preferredGender || 'Não informado'}</p>
                        <div class="flex items-center mt-2">
                            <span class="online-dot"></span>
                            <p class="text-sm text-white/90 ml-2">Online aqui no bar</p>
                        </div>
                    </div>
                </div>
                 <!-- Botões de Ação dentro do card, mais para cima e com tamanho fixo para arredondamento perfeito -->
                <div class="flex justify-center items-center p-4 space-x-8">
                    <button id="dislike-btn-${user.id}" class="w-14 h-14 flex items-center justify-center bg-gray-700 rounded-full text-white shadow-lg transform hover:scale-110 transition-transform">
                        <span class="material-icons">close</span>
                    </button>
                    <button id="like-btn-${user.id}" class="w-14 h-14 flex items-center justify-center bg-pink-600 rounded-full text-white shadow-lg transform hover:scale-110 transition-transform">
                        <span class="material-icons">favorite</span>
                    </button>
                </div>
            `;
            // Listener de clique para abrir perfil na imagem do card
            const cardImage = card.querySelector('img');
            if (cardImage) {
                cardImage.addEventListener('click', () => openUserProfileModal(user.id));
            }

            // Adiciona listeners para os botões de like/dislike específicos deste card
            card.querySelector(`#like-btn-${user.id}`).addEventListener('click', () => handleSwipe('like', user, true));
            card.querySelector(`#dislike-btn-${user.id}`).addEventListener('click', () => handleSwipe('dislike', user, true));

            return card;
        }

        // Função para abrir a modal de perfil do usuário
        async function openUserProfileModal(userId) {
            console.log(`openUserProfileModal: Tentando abrir perfil para o userId: ${userId}`);
            try {
                const userDoc = await getDoc(doc(db, `artifacts/${appId}/public/data/user_profiles`, userId));
                if (userDoc.exists()) {
                    const userData = userDoc.data();
                    console.log("openUserProfileModal: Dados do usuário carregados:", userData);
                    document.getElementById('user-profile-modal-img').src = userData.photoURL || 'https://placehold.co/150x150';
                    document.getElementById('user-profile-modal-name').textContent = userData.name || 'Usuário';
                    document.getElementById('user-profile-modal-name-main').textContent = userData.name || 'Usuário';
                    document.getElementById('user-profile-modal-bio').textContent = userData.bio || 'Sem bio.';
                    document.getElementById('user-profile-modal-gender').textContent = userData.gender || 'Não informado';
                    document.getElementById('user-profile-modal-preferred-gender').textContent = userData.preferredGender || 'Não informado';
                    userProfileModal.classList.remove('hidden');
                    console.log("openUserProfileModal: Classe 'hidden' removida do modal de perfil.");
                } else {
                    showMessage("Perfil do usuário não encontrado.");
                    console.warn(`openUserProfileModal: Perfil do usuário com ID ${userId} não encontrado no Firestore.`);
                }
            } catch (error) {
                console.error("Erro ao carregar perfil do usuário:", error);
                showMessage("Erro ao carregar o perfil. Detalhes: " + error.message);
            }
        }

        // Event listener para fechar a modal de perfil de usuário
        closeUserProfileModalBtn.addEventListener('click', () => {
            userProfileModal.classList.add('hidden');
            console.log("closeUserProfileModalBtn: Modal de perfil escondida.");
        });

        // 6. Interação com os Cards (Arrastar e Botões)
        function setupCardInteractions(card, user) {
             let startX;
             let isDragging = false;
             let currentX = 0; // Initialize currentX
             
             function onPointerDown(e) {
                 e.preventDefault();
                 startX = e.clientX;
                 isDragging = true;
                 card.classList.add('dragging');
                 card.style.transition = 'none'; // Desabilita transição durante o arrastar
                 document.addEventListener('pointermove', onPointerMove);
                 document.addEventListener('pointerup', onPointerUp);
             }

             function onPointerMove(e) {
                if (!isDragging) return;
                currentX = e.clientX;
                const diffX = currentX - startX;
                const rotate = diffX * 0.1;
                card.style.transform = `translateX(${diffX}px) rotate(${rotate}deg)`;
             }

             function onPointerUp(e) {
                if (!isDragging) return;
                isDragging = false;
                card.classList.remove('dragging');
                card.style.transition = 'transform 0.3s ease, opacity 0.3s ease'; // Reabilita transição
                document.removeEventListener('pointermove', onPointerMove);
                document.removeEventListener('pointerup', onPointerUp);

                const diffX = currentX - startX; // Use o último currentX
                if (Math.abs(diffX) > 100) {
                    if (diffX > 0) {
                        handleSwipe('like', user);
                    } else {
                        handleSwipe('dislike', user);
                    }
                } else {
                     card.style.transform = ''; // Volta à posição original
                }
             }

             card.addEventListener('pointerdown', onPointerDown);
        }

        // Os botões de like/dislike globais foram removidos do footer,
        // e agora estão embutidos em cada card para serem específicos do card.
        // A lógica de click agora é adicionada no createCardElement.

        async function handleSwipe(action, otherUser, fromButton = false) {
            console.log("handleSwipe: Tentando realizar swipe.");
            console.log("handleSwipe: currentUser.uid:", currentUser?.uid);
            console.log("handleSwipe: auth.currentUser?.uid:", auth.currentUser?.uid);

            if (!currentUser || !currentUser.uid) {
                showMessage("Erro: Não foi possível realizar o swipe. Utilizador não autenticado. Por favor, inicie sessão novamente.");
                console.error("handleSwipe: Usuário não autenticado no momento do swipe.");
                return;
            }

            if (!currentCard || !otherUser) return;
            const cardEl = currentCard;
            cardEl.style.transition = 'transform 0.3s ease, opacity 0.3s ease'; 
            cardEl.classList.add(action);

            try {
                const swipeRef = doc(db, `artifacts/${appId}/users/${currentUser.uid}/swipes`, otherUser.id);
                console.log(`handleSwipe: Tentando setDoc em: artifacts/${appId}/users/${currentUser.uid}/swipes/${otherUser.id}`);
                await setDoc(swipeRef, { action: action, timestamp: serverTimestamp() });
                console.log("handleSwipe: Swipe registrado com sucesso!");

                if (action === 'like') {
                    const otherUserSwipeRef = doc(db, `artifacts/${appId}/users/${otherUser.id}/swipes`, currentUser.uid);
                    const otherUserSwipeDoc = await getDoc(otherUserSwipeRef);

                    if (otherUserSwipeDoc.exists() && otherUserSwipeDoc.data().action === 'like') {
                        // Se um match já existe com este matchId (sorted UIDs), setDoc com merge:true irá atualizá-lo.
                        // Isso previne a criação de múltiplos documentos de match para o mesmo par.
                        await createMatch(otherUser);
                        showMatchModal(otherUser);
                    }
                }
            } catch (error) {
                console.error("Erro ao registar swipe:", error);
                if (error.code === 'permission-denied') {
                    showMessage("Erro de permissão ao registar a sua ação de 'swipe'. Por favor, verifique se está logado e que as regras do Firebase permitem escrever em 'users/{seu_uid}/swipes'. Detalhes: " + error.message);
                } else {
                    showMessage("Ocorreu um erro ao registar a sua ação. Detalhes: " + error.message);
                }
            }
            
            setTimeout(() => renderNextCard(), 300);
        }
        
        async function createMatch(otherUser) {
            console.log("createMatch: Tentando criar match.");
            console.log("createMatch: currentUser.uid:", currentUser?.uid);

            if (!currentUser || !currentUser.uid) {
                console.error("createMatch: Usuário não autenticado ao tentar criar match.");
                return;
            }

            try {
                // A ID do match é criada ordenando os UIDs dos usuários para garantir consistência.
                // Ex: "user1_user2" ou "user2_user1" sempre resultará em "user1_user2"
                const matchId = [currentUser.uid, otherUser.id].sort().join('_');
                const matchRef = doc(db, `artifacts/${appId}/public/data/matches`, matchId);
                console.log(`createMatch: Tentando setDoc em: artifacts/${appId}/public/data/matches/${matchId}`);
                await setDoc(matchRef, {
                    users: [currentUser.uid, otherUser.id],
                    barId: barId,
                    createdAt: serverTimestamp(),
                    // Inicializa lastMessageTimestamp para que a comparação funcione desde o início
                    lastMessageTimestamp: serverTimestamp(), 
                    lastMessageText: '', // Inicializa com string vazia para a última mensagem
                    lastReadTimestamps: { // Inicializa os timestamps de leitura para ambos
                        [currentUser.uid]: serverTimestamp(), // O que criou o match já leu
                        [otherUser.id]: new Timestamp(0, 0) // Outro utilizador ainda não leu
                    }
                }, { merge: true }); // O merge: true é crucial para atualizar, não criar um novo documento se a ID já existe.
                console.log("createMatch: Match criado com sucesso! ID:", matchId);

                // Nota sobre duplicação de conversas:
                // A lógica acima com 'matchId' único (baseado nos UIDs ordenados) e 'merge: true'
                // previne a criação de múltiplos documentos de match para o mesmo par de usuários.
                // Se você ainda observar conversas duplicadas, a causa provável é a existência
                // de documentos duplicados *já no seu Firestore* de testes, possivelmente
                // criados por versões anteriores do código que não tinham essa validação forte.
                // Para resolver isso, seria necessário inspecionar manualmente a coleção 'matches' no Firestore
                // e excluir quaisquer documentos de match que sejam duplicatas (tenham os mesmos 'users' mas IDs de documento diferentes).
            } catch (error) {
                console.error("Erro ao criar match:", error);
                if (error.code === 'permission-denied') {
                    showMessage("Erro de permissão ao criar um match. Verifique as regras do Firebase.");
                } else {
                    showMessage("Ocorreu um erro ao criar o match. Detalhes: " + error.message);
                }
            }
        }
        
        function listenForMatches() {
            // Desativa o listener existente, se houver, para evitar duplicações
            if (unsubscribeMatches) {
                console.log("listenForMatches: Desativando listener de matches anterior.");
                unsubscribeMatches(); 
            }

            // Garante que currentUser está disponível antes de tentar configurar o listener
            if (!currentUser || !currentUser.uid) {
                console.warn("listenForMatches: Nenhum utilizador atual ou UID disponível. Não é possível configurar o listener de matches.");
                matchesList.innerHTML = ''; // Ensure list is cleared if no user is logged in
                noMatchesFoundMsg.classList.remove('hidden');
                matchNotification.classList.add('hidden');
                return;
            }

            const matchesList = document.getElementById('matches-list');
            matchesList.innerHTML = ''; // Limpa a lista antes de adicionar novos matches para evitar elementos duplicados na UI
            noMatchesFoundMsg.classList.add('hidden'); // Esconde a mensagem de nenhum match inicialmente
            
            const q = query(collection(db, `artifacts/${appId}/public/data/matches`), where('users', 'array-contains', currentUser.uid));
            
            console.log("listenForMatches: Configurando onSnapshot para matches do usuário:", currentUser.uid);
            let hasUnreadMessagesGlobal = false; // Flag para verificar se há alguma conversa com mensagens não lidas

            unsubscribeMatches = onSnapshot(q, async (snapshot) => {
                console.log("listenForMatches: onSnapshot callback disparado. Change type:", snapshot.docChanges().map(c => c.type));
                
                // Mapeia os documentos para um array de objetos para facilitar o processamento
                const currentMatchesData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                // Atualiza a flag de mensagens não lidas globalmente
                hasUnreadMessagesGlobal = false; 

                // Mapeia os IDs dos matches que estão no snapshot atual para um Set
                const snapshotMatchIds = new Set(currentMatchesData.map(match => match.id));
                
                // Remove elementos do DOM que não estão mais no snapshot
                // É importante iterar sobre uma cópia da lista de filhos para evitar problemas ao remover elementos durante a iteração
                Array.from(matchesList.children).forEach(child => {
                    const matchId = child.dataset.matchId;
                    if (matchId && !snapshotMatchIds.has(matchId)) {
                        console.log("listenForMatches: Removendo elemento não encontrado no snapshot atual:", matchId);
                        matchesList.removeChild(child);
                    }
                });
                
                if (currentMatchesData.length === 0) {
                    noMatchesFoundMsg.classList.remove('hidden');
                    console.log("listenForMatches: NENHUM match encontrado para o usuário atual.");
                    matchNotification.classList.add('hidden');
                    return; 
                } else {
                    noMatchesFoundMsg.classList.add('hidden');
                }

                try {
                    // Adiciona ou atualiza os elementos de match
                    for (const matchData of currentMatchesData) { 
                        const otherUserId = matchData.users.find(id => id !== currentUser.uid);
                        const matchId = matchData.id;
                        const lastMessageText = matchData.lastMessageText || 'Toque para conversar'; // Pega a última mensagem, default se vazia
                        
                        if (!otherUserId) {
                            console.warn("listenForMatches: otherUserId nulo ou indefinido para o match", matchId);
                            continue;
                        }

                        // Calcula o status de não lido
                        // Garante que lastMessageTimestamp e currentUserLastReadTimestamp são números (0 se indefinido)
                        const currentUserLastReadTimestamp = matchData.lastReadTimestamps?.[currentUser.uid]?.toMillis() || 0;
                        const lastMessageTimestamp = matchData.lastMessageTimestamp?.toMillis() || 0; 
                        
                        // A bolinha deve aparecer APENAS se:
                        // 1. lastMessageTimestamp for MAIOR que o lastReadTimestamp do usuário atual
                        // 2. E o usuário NÃO estiver atualmente no chat com este matchId
                        const hasUnread = (lastMessageTimestamp > currentUserLastReadTimestamp) && (activeChatMatchId !== matchId);
                        
                        if (hasUnread) {
                            hasUnreadMessagesGlobal = true;
                        }

                        let matchElement = document.querySelector(`[data-match-id="${matchId}"]`);

                        if (matchElement) {
                            // Elemento já existe, apenas atualiza o badge e a última mensagem
                            console.log("listenForMatches: Atualizando elemento de match existente para o ID:", matchId);
                            const unreadBadge = matchElement.querySelector('.unread-badge'); // Seleciona pela classe
                            if (hasUnread) {
                                if (!unreadBadge) { // Se o badge não existe, cria
                                    const newBadge = document.createElement('span');
                                    newBadge.className = 'absolute top-2 right-2 w-3 h-3 bg-red-500 rounded-full unread-badge'; // Adiciona uma classe para seleção
                                    matchElement.appendChild(newBadge);
                                } else {
                                    unreadBadge.classList.remove('hidden'); // Garante que está visível
                                }
                            } else {
                                if (unreadBadge) {
                                    unreadBadge.classList.add('hidden'); // Esconde se não houver mensagens não lidas
                                }
                            }
                            // Atualiza o texto da última mensagem
                            matchElement.querySelector('.text-gray-400').textContent = lastMessageText;

                        } else {
                            // Elemento não existe, cria um novo
                            console.log("listenForMatches: Criando novo elemento de match para o ID:", matchId);
                            const userDoc = await getDoc(doc(db, `artifacts/${appId}/public/data/user_profiles`, otherUserId));
                            if (userDoc.exists()) {
                                const userData = userDoc.data();
                                matchElement = createMatchElement(matchId, otherUserId, userData.name, userData.photoURL, hasUnread, lastMessageText); // Passa lastMessageText
                                matchesList.appendChild(matchElement);
                            } else {
                                console.warn("listenForMatches: Perfil do outro usuário não encontrado para o ID:", otherUserId);
                            }
                        }
                    }

                } catch (error) {
                    console.error("Erro no listener de matches:", error);
                    if (error.code === 'permission-denied') {
                        showMessage("Erro de permissão ao carregar os seus matches. Verifique as regras de segurança do Firebase. Detalhes: " + error.message);
                    } else {
                        showMessage("Erro ao carregar matches. Detalhes: " + error.message);
                    }
                }
                // Atualiza a visibilidade da notificação global (apenas mostra/esconde a bolinha)
                matchNotification.classList.toggle('hidden', !hasUnreadMessagesGlobal);
                console.log(`listenForMatches: hasUnreadMessagesGlobal final: ${hasUnreadMessagesGlobal}. Match notification hidden: ${matchNotification.classList.contains('hidden')}`);

            }, (error) => { // Callback de erro para o próprio onSnapshot
                console.error("Erro de conexão do listener de matches:", error);
                if (error.code === 'permission-denied') {
                    showMessage("Problema de permissão no acesso a matches em tempo real. Verifique as regras do Firebase. Detalhes: " + error.message);
                } else {
                    showMessage("Erro na conexão com o serviço de matches. Detalhes: " + error.message);
                }
            });
        }

        // Função auxiliar para criar um elemento de match
        function createMatchElement(matchId, otherUserId, otherUserName, otherUserPhoto, hasUnread, lastMessageText) {
            const matchElement = document.createElement('div');
            matchElement.className = 'flex items-center p-3 hover:bg-gray-700 rounded-lg cursor-pointer relative';
            matchElement.dataset.matchId = matchId; 
            matchElement.dataset.otherUserId = otherUserId;
            matchElement.dataset.otherUserName = otherUserName;
            matchElement.dataset.otherUserPhoto = otherUserPhoto;

            matchElement.innerHTML = `
                <img src="${otherUserPhoto || 'https://placehold.co/50x50'}" class="w-12 h-12 rounded-full object-cover mr-4">
                <div class="flex-grow">
                    <p class="font-bold">${otherUserName}</p>
                    <p class="text-sm text-gray-400">${lastMessageText}</p> <!-- Agora exibe a última mensagem -->
                </div>
            `;
            // Adiciona a bolinha apenas se hasUnread for true
            if (hasUnread) {
                const unreadBadge = document.createElement('span');
                unreadBadge.className = 'absolute top-2 right-2 w-3 h-3 bg-red-500 rounded-full unread-badge';
                matchElement.appendChild(unreadBadge);
            }
            matchElement.addEventListener('click', () => openChat(matchElement.dataset));
            return matchElement;
        }

        // 7. Modais e Telas Secundárias (Perfil, Matches, Chat)
        async function showMatchModal(otherUser) {
            console.log("showMatchModal: Dados iniciais de otherUser:", otherUser);

            // Fetch the full user data again to ensure photoURL is present and up-to-date
            let fullOtherUserData = otherUser;
            try {
                const userDoc = await getDoc(doc(db, `artifacts/${appId}/public/data/user_profiles`, otherUser.id));
                if (userDoc.exists()) {
                    fullOtherUserData = { id: userDoc.id, ...userDoc.data() };
                    console.log("showMatchModal: Dados completos do otherUser após fetch:", fullOtherUserData);
                } else {
                    console.warn(`showMatchModal: Perfil do outro usuário (${otherUser.id}) não encontrado, usando dados parciais.`);
                }
            } catch (error) {
                console.error("showMatchModal: Erro ao buscar perfil completo do outro usuário:", error);
            }

            document.getElementById('match-name').textContent = fullOtherUserData.name || 'Usuário';
            document.getElementById('match-photo-user').src = profileImgPreview.src; 
            document.getElementById('match-photo-other').src = fullOtherUserData.photoURL || 'https://placehold.co/120x120/4a5568/ffffff?text=?';
            
            chatNowBtn.onclick = async () => {
                matchModal.classList.add('hidden');
                const matchId = [currentUser.uid, fullOtherUserData.id].sort().join('_');
                try {
                    // Re-obtem os dados do outro usuário para o openChat, garantindo que seja o mais atualizado
                    const userDoc = await getDoc(doc(db, `artifacts/${appId}/public/data/user_profiles`, fullOtherUserData.id));
                     if (userDoc.exists()) {
                        const userData = userDoc.data();
                        openChat({
                            matchId: matchId,
                            otherUserId: fullOtherUserData.id,
                            otherUserName: userData.name,
                            otherUserPhoto: userData.photoURL
                        });
                    }
                } catch (error) {
                    console.error("Erro ao abrir chat do modal:", error);
                    if (error.code === 'permission-denied') {
                        showMessage("Erro de permissão ao aceder dados para o chat. Verifique as regras do Firebase.");
                    } else {
                        showMessage("Não foi possível iniciar o chat. Detalhes: " + error.message);
                    }
                }
            };

            keepSwipingBtn.onclick = () => {
                 matchModal.classList.add('hidden');
            };

            matchModal.classList.remove('hidden');
            console.log("showMatchModal: Modal de match exibido.");
        }

        profileBtn.addEventListener('click', () => profileScreen.classList.remove('hidden'));
        backToAppFromProfile.addEventListener('click', () => profileScreen.classList.add('hidden'));

        // CORREÇÃO: Mostrar a app-screen ao voltar dos matches
        backToAppFromMatches.addEventListener('click', () => {
            matchesScreen.classList.add('hidden');
            appScreen.style.display = 'flex'; // Garante que a app-screen é exibida
            activeChatMatchId = null; // Garante que o chat ativo é limpado
            listenForMatches(); // Atualiza a lista de matches ao voltar
        });

        matchesBtn.addEventListener('click', () => {
            matchesScreen.classList.remove('hidden');
            appScreen.style.display = 'none'; // Esconde a app-screen ao ir para matches
            // matchNotification.classList.add('hidden'); // Essa linha não é mais necessária aqui
            // A notificação global será atualizada pelo listenForMatches()
        });
        
        // CORREÇÃO: Mostrar a app-screen ao voltar do chat para matches e vice-versa
        backToMatchesFromChat.addEventListener('click', () => {
            chatScreen.classList.add('hidden');
            matchesScreen.classList.remove('hidden');
            if (unsubscribeChat) {
                console.log("backToMatchesFromChat: Desativando listener de chat.");
                unsubscribeChat();
            }
            if (unsubscribeMatchDoc) { // NOVA: Desativa o listener do documento do match
                console.log("backToMatchesFromChat: Desativando listener do documento do match.");
                unsubscribeMatchDoc();
            }
            currentChatMatch = null;
            activeChatMatchId = null; // Limpa o chat ativo ao sair do chat
            currentMessagesCache = []; // Limpa o cache de mensagens
            otherUserLastReadTimestamp = 0; // Reseta o timestamp de leitura do outro usuário
            listenForMatches(); // Força a atualização da lista de matches para refletir o status de "lido"
        });
        
        // Event listener para pré-visualização da foto no perfil
        profilePhotoInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                try {
                    // Redimensiona para uma pré-visualização mais leve
                    const base64String = await resizeImageAndConvertToBase64(file, MAX_IMAGE_WIDTH, MAX_IMAGE_HEIGHT);
                    profileImgPreview.src = base64String;
                } catch (error) {
                    console.error("Erro na pré-visualização da imagem (Base64):", error);
                    showMessage("Não foi possível carregar a pré-visualização da imagem. Tente outra imagem.");
                }
            } else {
                // Se nenhum arquivo for selecionado, reverte para a foto atual salva ou placeholder
                loadUserProfile(); 
            }
        });


        async function loadUserProfile() {
            try {
                // Garante que currentUser está disponível antes de prosseguir com as queries do Firestore
                if (!currentUser || !currentUser.uid) {
                    console.warn("loadUserProfile: Nenhum utilizador atual ou UID disponível. Não é possível carregar perfil.");
                    profileImgPreview.src = 'https://placehold.co/150x150';
                    document.getElementById('profile-name').value = '';
                    document.getElementById('profile-bio').value = '';
                    document.getElementById('profile-gender').value = '';
                    document.getElementById('profile-preferred-gender').value = '';
                    return;
                }
                const userDoc = await getDoc(doc(db, `artifacts/${appId}/public/data/user_profiles`, currentUser.uid));
                if(userDoc.exists()){
                    const data = userDoc.data();
                    profileImgPreview.src = data.photoURL || 'https://placehold.co/150x150';
                    document.getElementById('profile-name').value = data.name || '';
                    document.getElementById('profile-bio').value = data.bio || '';
                    document.getElementById('profile-gender').value = data.gender || '';
                    document.getElementById('profile-preferred-gender').value = data.preferredGender || '';
                } else {
                    profileImgPreview.src = 'https://placehold.co/150x150';
                    document.getElementById('profile-name').value = '';
                    document.getElementById('profile-bio').value = '';
                    document.getElementById('profile-gender').value = '';
                    document.getElementById('profile-preferred-gender').value = '';
                }
            } catch (error) {
                console.error("Erro ao carregar perfil do utilizador:", error);
                if (error.code === 'permission-denied') {
                    showMessage("Erro de permissão ao carregar o seu perfil. Verifique as regras de segurança do Firebase.");
                } else {
                    showMessage("Erro ao carregar o seu perfil. Detalhes: " + error.message);
                }
            }
        }
        
        profileForm.addEventListener('submit', async (e) => {
             e.preventDefault();
             profileSpinner.classList.remove('hidden'); // Mostra spinner
             const name = document.getElementById('profile-name').value;
             const bio = document.getElementById('profile-bio').value;
             const gender = document.getElementById('profile-gender').value;
             const preferredGender = document.getElementById('profile-preferred-gender').value;
             
             const file = profilePhotoInput.files[0];
             let photoURL = profileImgPreview.src; // Começa com o URL da imagem atual

             try {
                // Garante que currentUser está disponível antes de prosseguir com as operações do Firestore
                if (!currentUser || !currentUser.uid) {
                    showMessage("Erro: Não foi possível atualizar o perfil. Utilizador não autenticado.");
                    return;
                }

                if (file) {
                    photoURL = await resizeImageAndConvertToBase64(file, MAX_IMAGE_WIDTH, MAX_IMAGE_HEIGHT); // Converte a nova imagem para Base64
                }

                await setDoc(doc(db, `artifacts/${appId}/public/data/user_profiles`, currentUser.uid), {
                    name,
                    bio,
                    photoURL, // Armazenando a string Base64
                    gender, 
                    preferredGender, 
                }, { merge: true });
                await showMessage("Perfil atualizado com sucesso!");
                profileScreen.classList.add('hidden');
                await loadUserProfile(); 
             } catch(error) {
                console.error("Erro ao atualizar perfil:", error);
                if (error.code === 'permission-denied') {
                    showMessage("Erro de permissão ao atualizar o seu perfil. Verifique as regras de segurança do Firebase. Detalhes: " + error.message);
                } else if (error.message && error.message.includes("is longer than")) {
                    showMessage("A imagem selecionada é muito grande. Por favor, selecione uma imagem menor.");
                }
                else {
                    showMessage("Erro ao atualizar o perfil. Detalhes: " + error.message);
                }
             } finally {
                 profileSpinner.classList.add('hidden'); // Esconde spinner
             }
        });

        // 8. Lógica do Chat
        async function openChat(matchDetails) { 
            currentChatMatch = matchDetails;
            activeChatMatchId = matchDetails.matchId; // Define o chat ativo
            chatScreen.classList.remove('hidden');
            appScreen.style.display = 'none'; 
            matchesScreen.classList.add('hidden'); 

            const chatHeaderImg = document.getElementById('chat-header-img');
            const chatHeaderName = document.getElementById('chat-header-name'); 
            const messagesContainer = document.getElementById('chat-messages');
            
            chatHeaderName.textContent = matchDetails.otherUserName;
            chatHeaderImg.src = matchDetails.otherUserPhoto;
            
            // Adiciona o event listener para abrir o perfil ao clicar na imagem do cabeçalho do chat
            // Remove o listener anterior para evitar duplicações
            chatHeaderImg.removeEventListener('click', chatHeaderImg._openProfileListener); 
            chatHeaderImg._openProfileListener = () => openUserProfileModal(matchDetails.otherUserId);
            chatHeaderImg.addEventListener('click', chatHeaderImg._openProfileListener);

            // Adiciona o event listener para abrir o perfil ao clicar no nome do cabeçalho do chat
            // Remove o listener anterior para evitar duplicações
            chatHeaderName.removeEventListener('click', chatHeaderName._openProfileListener); 
            chatHeaderName._openProfileListener = () => openUserProfileModal(matchDetails.otherUserId);
            chatHeaderName.addEventListener('click', chatHeaderName._openProfileListener);

            messagesContainer.innerHTML = ''; 
            noMessagesYetMsg.classList.add('hidden'); 

            // Desativa os listeners existentes, se houver, para evitar duplicações
            if (unsubscribeChat) {
                console.log("openChat: Desativando listener de chat anterior.");
                unsubscribeChat(); 
            }
            if (unsubscribeMatchDoc) {
                console.log("openChat: Desativando listener do documento do match anterior.");
                unsubscribeMatchDoc();
            }
            
            const matchRef = doc(db, `artifacts/${appId}/public/data/matches`, matchDetails.matchId);
            const messagesRef = collection(db, `artifacts/${appId}/public/data/matches/${matchDetails.matchId}/messages`);
            const messagesQuery = query(messagesRef); 

            // Função para renderizar as mensagens
            const renderMessages = (messagesToRender, currentOtherUserLastReadTimestamp) => {
                messagesContainer.innerHTML = '';
                if (messagesToRender.length === 0) {
                    noMessagesYetMsg.classList.remove('hidden'); 
                } else {
                    noMessagesYetMsg.classList.add('hidden'); 
                }

                messagesToRender.forEach(msg => {
                    const isSender = msg.senderId === currentUser.uid;
                    const messageEl = document.createElement('div');
                    
                    let statusText = '';
                    // Se a mensagem foi enviada por MIM, verifico se o OUTRO usuário leu
                    if (isSender) {
                        const messageTimestamp = msg.timestamp?.toMillis() || 0;
                        if (currentOtherUserLastReadTimestamp >= messageTimestamp) {
                            statusText = 'Lida';
                        } else {
                            statusText = 'Enviada';
                        }
                    }

                    messageEl.className = `flex flex-col mb-2 ${isSender ? 'items-end' : 'items-start'}`; // Ajuste para status ficar abaixo
                    messageEl.innerHTML = `
                        <div class="max-w-xs lg:max-w-md px-4 py-2 rounded-2xl ${isSender ? 'bg-pink-600 text-white rounded-br-none' : 'bg-gray-600 text-white rounded-bl-none'}">
                            <p>${msg.text}</p>
                        </div>
                        ${isSender && statusText ? `<p class="text-xs text-gray-400 mt-1 mr-1">${statusText}</p>` : ''} <!-- Adicionado mr-1 para espaçamento -->
                    `;
                    messagesContainer.appendChild(messageEl);
                });
                // Rola para o fim das mensagens para mostrar as mais recentes
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            };

            // 1. Listener para o documento do match (para pegar o lastReadTimestamps do outro usuário em tempo real)
            console.log("openChat: Configurando onSnapshot para o documento do match:", matchDetails.matchId);
            unsubscribeMatchDoc = onSnapshot(matchRef, (matchDocSnapshot) => {
                if (matchDocSnapshot.exists()) {
                    const matchData = matchDocSnapshot.data();
                    const otherUserId = matchData.users.find(id => id !== currentUser.uid);
                    otherUserLastReadTimestamp = matchData.lastReadTimestamps?.[otherUserId]?.toMillis() || 0;
                    console.log("openChat: otherUserLastReadTimestamp atualizado:", otherUserLastReadTimestamp);
                    
                    // Re-renderiza as mensagens com o novo status de leitura do outro usuário
                    if (currentMessagesCache.length > 0) {
                        renderMessages(currentMessagesCache, otherUserLastReadTimestamp);
                    }
                }
            }, (error) => {
                console.error("Erro de conexão do listener do documento do match:", error);
                if (error.code === 'permission-denied') {
                    showMessage("Problema de permissão no acesso aos dados do match em tempo real. Verifique as regras do Firebase.");
                } else {
                    showMessage("Erro na conexão com os dados do match. Detalhes: " + error.message);
                }
            });


            // 2. Listener para as mensagens do chat
            console.log("openChat: Configurando onSnapshot para mensagens do chat:", matchDetails.matchId);
            unsubscribeChat = onSnapshot(messagesQuery, async (snapshot) => {
                let messages = [];
                snapshot.forEach(doc => {
                    messages.push(doc.data());
                });

                console.log("openChat: Mensagens recebidas:", messages.length, messages);

                messages.sort((a, b) => (a.timestamp?.toMillis() || 0) - (b.timestamp?.toMillis() || 0)); 
                currentMessagesCache = messages; // Atualiza o cache de mensagens

                // Renderiza as mensagens com o timestamp de leitura atual do outro usuário
                renderMessages(messages, otherUserLastReadTimestamp);

                // Atualiza o timestamp de leitura do usuário atual no documento do match
                if (activeChatMatchId === matchDetails.matchId) { 
                    try {
                        await setDoc(matchRef, {
                            lastReadTimestamps: {
                                [currentUser.uid]: serverTimestamp()
                            }
                        }, { merge: true });
                        console.log("openChat: Timestamp de leitura atualizado (em tempo real no chat, com base no serverTimestamp) para o match:", matchDetails.matchId);
                    } catch (error) {
                        console.error("openChat: Erro ao atualizar timestamp de leitura (em tempo real no chat):", error);
                    }
                }

                // Esconde a bolinha na UI imediatamente para feedback visual se o chat está ativo
                const matchElementInList = document.querySelector(`#matches-list [data-match-id="${matchDetails.matchId}"]`);
                if (matchElementInList) {
                    const unreadBadge = matchElementInList.querySelector('.unread-badge');
                    if (unreadBadge) {
                        unreadBadge.classList.add('hidden');
                        console.log("openChat: Bolinha de não lido escondida imediatamente na UI para o match:", matchDetails.matchId);
                    }
                }

            }, (error) => {
                console.error("Erro de conexão do listener de chat:", error);
                if (error.code === 'permission-denied') {
                    showMessage("Problema de permissão no acesso ao chat em tempo real. Verifique as regras do Firebase. Detalhes: " + error.message);
                } else {
                    showMessage("Erro na conexão com o chat. Detalhes: " + error.message);
                }
            });
        }
        
        // Ao voltar do chat para matches, garanta que matches-screen está visível e chat-screen está escondida.
        backToMatchesFromChat.addEventListener('click', () => {
            chatScreen.classList.add('hidden');
            matchesScreen.classList.remove('hidden');
            if (unsubscribeChat) {
                console.log("backToMatchesFromChat: Desativando listener de chat.");
                unsubscribeChat();
            }
            if (unsubscribeMatchDoc) { // Desativa o listener do documento do match
                console.log("backToMatchesFromChat: Desativando listener do documento do match.");
                unsubscribeMatchDoc();
            }
            currentChatMatch = null;
            activeChatMatchId = null; // Limpa o chat ativo ao sair do chat
            currentMessagesCache = []; // Limpa o cache de mensagens
            otherUserLastReadTimestamp = 0; // Reseta o timestamp de leitura do outro usuário
            listenForMatches(); // Força a atualização da lista de matches para refletir o status de "lido"
        });
        
        chatForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const input = document.getElementById('chat-input');
            const text = input.value.trim();
            if(text === '' || !currentChatMatch) return;

            input.value = '';
            
            try {
                const messagesRef = collection(db, `artifacts/${appId}/public/data/matches/${currentChatMatch.matchId}/messages`);
                await addDoc(messagesRef, {
                    text: text,
                    senderId: currentUser.uid,
                    timestamp: serverTimestamp()
                });

                // --- NEW: Update lastMessageTimestamp and lastMessageText on the match document ---
                const matchRef = doc(db, `artifacts/${appId}/public/data/matches`, currentChatMatch.matchId);
                await setDoc(matchRef, {
                    lastMessageTimestamp: serverTimestamp(),
                    lastMessageText: text, // Adiciona a última mensagem ao documento do match
                    lastReadTimestamps: {
                        [currentUser.uid]: serverTimestamp() // Atualiza o timestamp de leitura para o remetente
                    }
                }, { merge: true });
                console.log("chatForm: lastMessageTimestamp, lastMessageText e lastReadTimestamps para o remetente atualizados no match:", currentChatMatch.matchId);
                // --- END NEW ---\

            } catch (error) {
                console.error("Erro ao enviar mensagem:", error);
                if (error.code === 'permission-denied') {
                    showMessage("Erro de permissão ao enviar mensagem. Verifique as regras do Firebase.");
                } else {
                    showMessage("Ocorreu um erro ao enviar a sua mensagem. Detalhes: " + error.message);
                }
            }
        });
        
    </script>
</body>
</html>
